// Includes
#include <stdio.h>
#include "driver/gpio.h"
#include <rom/ets_sys.h>
#include "driver/uart.h"
#include "nvs.h"
#include "nvs_flash.h"
#include <string.h>
#include "esp_err.h"
#include "esp_log.h"
#include "freertos/task.h"
#include "sdkconfig.h" // generated by "make menuconfig"
#include "sh1106.h"
#include "font8x8_basic.h"
#include "driver/ledc.h"
#include "esp_adc/adc_cali.h"
#include "esp_adc/adc_cali_scheme.h"
#include "esp_adc/adc_oneshot.h"





// Display Fan Control Modes
#define MODE_CURVE 0
#define MODE_POWER 1


// EEPROM CONSTANTS AND GLOBAL VARIABLES
#define EEPROM_SIZE 512
#define FAN_CURVE_LENGTH 10
#define DEFAULT_FAN_CURVE {25, 30, 40, 50, 60, 70, 80, 85, 90, 100}
#define DEFAULT_FAN_POWER_PERCENTAGE 25
#define FAN1_NUM 0
#define FAN2_NUM 1
#define FAN3_NUM 2
#define FAN4_NUM 3

#define FAN_SPEED_MEMORY_OFFSET 50
#define UART_BUFFER_SIZE 1024

bool fan_mode_record[4]; // True = Speed mode, False = Curve mode
bool fan_mode_change[4];  // True if the fan mode or speed has been changed
bool fan_mode_change_display[4]; // True if the fan mode has been changed
bool fan_curve_change[4]; // True if the curve has been changed

////////////////////////////////////////////////////////////

// LEDC TIMER CONSTANTS AND GLOBAL VARIABLES
#define FAN1_PIN GPIO_NUM_32 // GPIO pin connected to the PWM input of the fan 32
#define FAN2_PIN GPIO_NUM_33
#define FAN3_PIN GPIO_NUM_25
#define FAN4_PIN GPIO_NUM_12


// Global variables for the LEDC peripheral
#define FAN1_CHANNEL LEDC_CHANNEL_0
#define FAN2_CHANNEL LEDC_CHANNEL_1
#define FAN3_CHANNEL LEDC_CHANNEL_2
#define FAN4_CHANNEL LEDC_CHANNEL_3

#define LEDC_TIMER LEDC_TIMER_0
#define LEDC_MODE LEDC_LOW_SPEED_MODE
#define LEDC_FREQ 25000
#define LEDC_RESOLUTION LEDC_TIMER_8_BIT

///////////////////////////////////////////////////////////////

// I2C CONSTANTS AND GLOBAL VARIABLES
static uint8_t SDA_PIN_ADC;
static uint8_t SCL_PIN_ADC;
static uint8_t SDA_PIN_OLED;
static uint8_t SCL_PIN_OLED;
static bool start_status = false;

// GLOBAL CONSTANTS
#define HIGH 0x01
#define LOW 0X00
#define ACK 0x00
#define NACK 0x01
#define WRITE_BIT 0
#define READ_BIT 1

// I2C TIMING CONSTRAINTS
#define I2C_DELAY_ADC 10
#define I2C_DELAY_OLED 1
#define CONVERSION_DELAY 25
#define CONFIGURATION_DELAY 10 // Increase this if necessary

// ADC REGISTER ADDRESSES

// ADS1115 ADDRESSES
#define ADS1115_ADDR1 0x48  
#define ADS1115_ADDR2 0x49  
#define CONVERSION_REG 0x00
#define CONFIG_REG 0x01

// ERROR VAIRBLES FOR READING 
bool error_sda;
bool error_scl;
int count;
bool lock;

// BUTTON CONSTANTS

#define NAVIGATE_BUTTON GPIO_NUM_14
#define CONFIRM_BUTTON GPIO_NUM_13
#define BACK_BUTTON GPIO_NUM_4
bool display_mode = true; // True for all fan info false for individual


////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

// I2C FUNCTIONS

// i2c_configure_gpio
//
// Configures the chosen GPIO pins for I2C communication
void i2c_configure_gpio(uint8_t sda_pin, uint8_t scl_pin, bool for_adc)
{
    printf("Configuring GPO pins for I2C communication...\n");
    
    // Select the pins for ADC or OLED communication
    if (for_adc)
    {
        SDA_PIN_ADC = sda_pin;
        SCL_PIN_ADC = scl_pin;
    }
    else
    {
        SDA_PIN_OLED = sda_pin;
        SCL_PIN_OLED = scl_pin;
    }

    // Configure the SDA pin
    gpio_set_direction(sda_pin,GPIO_MODE_INPUT_OUTPUT_OD);
    gpio_set_pull_mode(sda_pin, GPIO_FLOATING);

    // Configure the SCL pin
    gpio_set_direction(scl_pin,GPIO_MODE_INPUT_OUTPUT_OD);
    gpio_set_pull_mode(scl_pin, GPIO_FLOATING);

    gpio_set_level(sda_pin, HIGH);
    gpio_set_level(scl_pin, HIGH);
    ets_delay_us(10);
}

// i2c_start_condition
//
// Signals the start condition for I2C communication
void i2c_start_condition(uint8_t sda_pin, uint8_t scl_pin, uint8_t i2c_delay)
{   
    // Check if there is an active I2C communication, if so prepare the bus for a repeated start condition
    if (start_status)
    {
        gpio_set_level(sda_pin, HIGH);
        ets_delay_us(i2c_delay);
        gpio_set_level(scl_pin, HIGH);
        ets_delay_us(i2c_delay);
    }


    gpio_set_level(sda_pin, LOW);
    ets_delay_us(i2c_delay);

    gpio_set_level(scl_pin, LOW);
    ets_delay_us(i2c_delay);


    start_status = true;
}

// i2c_stop_condition
//
// Signals the stop condition for I2C communication
void i2c_stop_condition(uint8_t sda_pin, uint8_t scl_pin, uint8_t i2c_delay)
{   
    // Prepare the bus for a stop condition
    gpio_set_level(sda_pin, LOW);
    ets_delay_us(i2c_delay);
    gpio_set_level(scl_pin, HIGH);

    ets_delay_us(i2c_delay);
    
    // Signal a stop condition 
    gpio_set_level(sda_pin, HIGH);
    ets_delay_us(i2c_delay);

    start_status = false;
}

// i2c_write_bit
//
// Send a bit over the I2C bus
void i2c_write_bit(bool bit,uint8_t sda_pin, uint8_t scl_pin, uint8_t i2c_delay)
{
    gpio_set_level(sda_pin, bit); 
    ets_delay_us(i2c_delay);
    gpio_set_level(scl_pin, HIGH);
    
    ets_delay_us(i2c_delay);

    /*if (gpio_get_level(sda_pin) == LOW && bit)
    {
        printf("SDA remains low even though bit (1) is being written\n");
    }*/
    gpio_set_level(scl_pin, LOW);
}

// i2c_read_bit
//
// Read a bit from the I2C bus
bool i2c_read_bit(uint8_t sda_pin, uint8_t scl_pin, uint8_t i2c_delay)
{   
    // Set SDA to high impedance (input mode) for reading
    gpio_set_level(sda_pin, HIGH);
    ets_delay_us(i2c_delay);

    // Check if SDA was successfully set to high-impedance
    /*if (gpio_get_level(sda_pin) != HIGH)
    {
        if (!lock) {  // Store the bit position of the first error
            lock = true;  // Lock after the first error to prevent further changes
        }
        error_sda = true;
    }
    else if (!lock)
    {
        count++;
    }*/

    gpio_set_level(scl_pin, HIGH);
    ets_delay_us(i2c_delay);

    bool bit = gpio_get_level(sda_pin); // Read the bit from SDA

    gpio_set_level(scl_pin, LOW);
    ets_delay_us(i2c_delay);

    return bit;
}

// i2c_write_byte
//
// Sends a byte over the I2C bus
bool i2c_write_byte(uint8_t byte, uint8_t sda_pin, uint8_t scl_pin, uint8_t i2c_delay) 
{
  
    for (int i = 0; i < 8; i++)
    {
        i2c_write_bit(((byte & 0x80) != 0), sda_pin, scl_pin, i2c_delay);
        byte <<= 1;
    }

    
    bool ack_received = !i2c_read_bit(sda_pin, scl_pin, i2c_delay); // Read ACK
    //printf("SDA Error: %s, SCL Error: %s\n", error_sda ? "true" : "false", error_scl ? "true" : "false");

    if (!ack_received) {
        printf("Failed to receive ACK for byte 0x%02X\n", byte);
    }
    return ack_received;
}

// i2c_read_byte
//
// Reads a byte from the I2C bus
uint8_t i2c_read_byte(bool ack_or_nack, uint8_t sda_pin, uint8_t scl_pin, uint8_t i2c_delay)
{
    uint8_t byte = 0;

    for (int i = 0; i < 8; i++)
    {
        byte <<= 1;           // Shift current bits in 'byte' to the left by 1 to make room for the next bit
        bool bit = i2c_read_bit(sda_pin, scl_pin, i2c_delay); // Read the next bit from the I2C bus
        byte |= bit;          // Add the bit just read to the least significant position in 'byte'
    }   

    i2c_write_bit(ack_or_nack, sda_pin, scl_pin, i2c_delay); // Send the ACK/NACK bit after reading the byte

    return byte;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

// ADS1115 ADC Functions


// ads1115_write_reg
//
// Writes a 16 bit value to a register of ADS1115
void ads1115_write_reg(uint8_t adc_addr, uint8_t reg, uint16_t data)
{
    i2c_start_condition(SDA_PIN_ADC, SCL_PIN_ADC, I2C_DELAY_ADC); 

    if (!i2c_write_byte(((adc_addr << 1) | 0), SDA_PIN_ADC, SCL_PIN_ADC, I2C_DELAY_ADC))
    {
        printf("Failed to communicate with ADS1115 at address 0x%02X\n", adc_addr);
        i2c_stop_condition(SDA_PIN_ADC, SCL_PIN_ADC, I2C_DELAY_ADC);
        return;
    }

    if (!i2c_write_byte(reg, SDA_PIN_ADC, SCL_PIN_ADC, I2C_DELAY_ADC))
    {
        printf("Failed to write to register 0x%02X\n", reg);
        i2c_stop_condition(SDA_PIN_ADC, SCL_PIN_ADC, I2C_DELAY_ADC);
        return;
    }

    if (!i2c_write_byte(((data >> 8) & 0xFF), SDA_PIN_ADC, SCL_PIN_ADC, I2C_DELAY_ADC))
    {
        printf("Failed to write MSB of data to register 0x%02X\n", reg);
        i2c_stop_condition(SDA_PIN_ADC, SCL_PIN_ADC, I2C_DELAY_ADC);
        return;
    }

    if (!i2c_write_byte((data & 0xFF), SDA_PIN_ADC, SCL_PIN_ADC, I2C_DELAY_ADC))
    {
        printf("Failed to write LSB of data to register 0x%02X\n", reg);
        i2c_stop_condition(SDA_PIN_ADC, SCL_PIN_ADC, I2C_DELAY_ADC);
        return;
    }

    i2c_stop_condition(SDA_PIN_ADC, SCL_PIN_ADC, I2C_DELAY_ADC); 
}


// ads1115_read_reg
//
// Reads a 16 bit value from a register of ADS1115
uint16_t ads1115_read_reg(uint8_t adc_addr, uint8_t reg) {
    i2c_start_condition(SDA_PIN_ADC, SCL_PIN_ADC, I2C_DELAY_ADC);
    
    if (!i2c_write_byte((adc_addr << 1) | 0, SDA_PIN_ADC, SCL_PIN_ADC, I2C_DELAY_ADC)) { // Send address + write
        printf("Failed to write device address 0x%02X for writing register\n", adc_addr);
        i2c_stop_condition(SDA_PIN_ADC, SCL_PIN_ADC, I2C_DELAY_ADC);
        return 0xFFFF; // Indicate failure with an error code
    }

    if (!i2c_write_byte(reg, SDA_PIN_ADC, SCL_PIN_ADC, I2C_DELAY_ADC)) { // Send register address
        printf("Failed to write register address 0x%02X\n", reg);
        i2c_stop_condition(SDA_PIN_ADC, SCL_PIN_ADC, I2C_DELAY_ADC);
        return 0xFFFF; // Indicate failure with an error code
    }

    i2c_start_condition(SDA_PIN_ADC, SCL_PIN_ADC, I2C_DELAY_ADC);
    
    if (!i2c_write_byte((adc_addr << 1) | 1, SDA_PIN_ADC, SCL_PIN_ADC, I2C_DELAY_ADC)) { // Send address + read
        printf("Failed to write device address 0x%02X for reading register\n", adc_addr);
        i2c_stop_condition(SDA_PIN_ADC, SCL_PIN_ADC, I2C_DELAY_ADC);
        return 0xFFFF; // Indicate failure with an error code
    }

    uint16_t msb = i2c_read_byte(ACK, SDA_PIN_ADC, SCL_PIN_ADC, I2C_DELAY_ADC);   // Read MSB
    uint16_t lsb = i2c_read_byte(NACK, SDA_PIN_ADC, SCL_PIN_ADC, I2C_DELAY_ADC);  // Read LSB

    i2c_stop_condition(SDA_PIN_ADC, SCL_PIN_ADC, I2C_DELAY_ADC);

    //printf("Read 16-bit value from register 0x%02X: 0x%04X\n", reg, (msb << 8) | lsb);
    
    return (msb << 8) | lsb;
}

// ads1115_create_config
//
// Creates a config to be written to the config register of ADS1115
uint16_t ads1115_create_config(int channel, bool single_shot_mode, uint8_t data_rate)
{
    if (channel > 3) {
        channel = 0;
    }

    uint16_t config = 0;


    // OS
    // 1 means start a single conversion
    config |= (1 << 15);

    // MUX 
    uint8_t mux_setting = 0x04 + channel; 
    config |= (mux_setting & 0x07) << 12;

    // PGA (4.096V)
    config |= (0x01 << 9);

    // MODE
    config |= (single_shot_mode << 8);

    // DATA RATE
    config |= (data_rate & 0x07) << 5;

    // COMP_MODE: 
    config |= (0x00 << 4);  // Traditional comparator, active low, non-latching

    // DISABLE THE COMPARATOR
    config |= 0x03;

    //printf("Creating config for channel %d: 0x%04X\n", channel, config);

    return config;
}

// ads1115_configure
//
// Configures the ADS1115 to read from a given channel in given mode and data rate
void ads1115_configure(uint8_t adc_addr, int channel, bool single_shot_mode, uint8_t data_rate)
{
    uint16_t config = ads1115_create_config(channel, single_shot_mode, data_rate);
    ads1115_write_reg(adc_addr, CONFIG_REG, config);

    vTaskDelay(pdMS_TO_TICKS(CONFIGURATION_DELAY)); 
}

// check_conversion_status
//
// Checks if the conversion register is ready to be read
bool check_conversion_status()
{
    uint16_t config = ads1115_read_reg(ADS1115_ADDR1, CONFIG_REG);
    return (config & 0x8000) != 0;  // Check if OS bit is set
}

// ads1115_read_conversion
//
// Reads a 16 bit raw ADC value from the conversion register of ADS1115
uint16_t ads1115_read_conversion(uint8_t adc_addr)
{
    while (!check_conversion_status()) {
        ets_delay_us(10);  // Small delay to avoid busy-waiting too hard
    }

    uint16_t adc_raw = ads1115_read_reg(adc_addr, CONVERSION_REG);
    
    if (adc_raw == 0xFFFF) {
        printf("Failed to read conversion result from ADC\n");
    } /*else {
        printf("Raw ADC value: %d\n", adc_raw);
    }*/
    
    return adc_raw;
}

// adc_to_temperature
//
// Converts raw ADC values to temperature readings in celcius 
float adc_to_temperature(int16_t adc_raw) {
    float adc_voltage = adc_raw * 0.125 / 1000; // Convert raw ADC value to voltage in volts
    float temp = adc_voltage * 100.0;  // Convert voltage to temperature (10mV per degree Celsius)
    //printf("Converted ADC voltage: %f mV" , adc_voltage);
    return temp;
}

// ads_1115_read_all
//
// Reads all 4 channels of the ADS1115
void ads1115_read_all(uint8_t adc_addr, float* fan_temps) {
    for (uint8_t channel = 0; channel < 4; channel++) 
    {   
        // Configure the ADS1115 for the channel
        ads1115_configure(ADS1115_ADDR1, channel, true, 4);
        vTaskDelay(pdMS_TO_TICKS(CONVERSION_DELAY)); // Allow time for the ADC to perform a single-shot conversion

        // Read the conversion result and calculate the temperature
        int16_t adc_raw = ads1115_read_conversion(adc_addr);
        float temp = adc_to_temperature(adc_raw);
        fan_temps[channel] = temp;

    // Print the result for this channel
        //printf("Channel %d: Temperature = %.2f°C\n", channel, temp);
    }
    //printf("\n");
}

//////////////////////////////////////////////////////////////////////////////////////////////

// EEPROM FUNCTIONS

// eeprom_write_byte
//
// Writes a byte of data to flash memory simulating eeprom
esp_err_t eeprom_write_byte(size_t address, uint8_t data) {
    if (address >= EEPROM_SIZE) {
        return ESP_ERR_INVALID_ARG; // Return error for invalid argument
    }

    nvs_handle_t handle;
    esp_err_t result = nvs_open("storage", NVS_READWRITE, &handle);
    if (result != ESP_OK) {
        return result;
    }

    char key[16];
    sprintf(key, "addr_%zu", address); // Generate a key for the address

    result = nvs_set_u8(handle, key, data);
    if (result != ESP_OK) {
        nvs_close(handle);
        return result;
    }

    result = nvs_commit(handle);  // Commit the changes to ensure they are written to flash
    nvs_close(handle);  // Close the NVS handle to free resources

    return result; // Return the result of nvs_commit (ESP_OK if successful)
}

// eeprom_read_byte
//
// Reads a byte of data from flash memory simulating eeprom
esp_err_t eeprom_read_byte(size_t address, uint8_t *data) {
    if (address >= EEPROM_SIZE) {
        return ESP_ERR_INVALID_ARG; // Return error for invalid argument
    }

    nvs_handle_t handle;
    esp_err_t result = nvs_open("storage", NVS_READONLY, &handle);
    if (result != ESP_OK) {
        return result;
    }

    char key[16];
    sprintf(key, "addr_%zu", address); // Generate a key for the address

    result = nvs_get_u8(handle, key, data);
    nvs_close(handle);  // Close the NVS handle to free resources

    return result; // Return the result of nvs_get_u8 (ESP_OK if successful)
}

// eeprom_read_block
//
// Reads a block of data from flash memory simulating eeprom
esp_err_t eeprom_read_block(size_t address, void *data, size_t length) {
    if (address + length > EEPROM_SIZE) {
        return ESP_ERR_INVALID_ARG;
    }

    nvs_handle_t handle;
    esp_err_t result = nvs_open("storage", NVS_READONLY, &handle);
    if (result != ESP_OK) {
        return result;
    }

    char key[16];
    sprintf(key, "addr_%zu", address);  // %zu is used for size_t format specifier

    size_t size = length;
    result = nvs_get_blob(handle, key, data, &size);
    nvs_close(handle);

    return result;
}

// eepromt_write_block
//
// Writes a block of data to flash memory simulating eeprom
esp_err_t eeprom_write_block(size_t address, const void *data, size_t length) {
    if (address + length > EEPROM_SIZE) {
        return ESP_ERR_INVALID_ARG;
    }

    nvs_handle_t handle;
    esp_err_t result = nvs_open("storage", NVS_READWRITE, &handle);
    if (result != ESP_OK) {
        return result;
    }

    char key[16];
    sprintf(key, "addr_%zu", address);  // Generate a key based on the address

    result = nvs_set_blob(handle, key, data, length);
    if (result != ESP_OK) {
        nvs_close(handle);
        return result;
    }

    result = nvs_commit(handle);
    nvs_close(handle);

    return result;
}

// load_fan_curve
//
// Loads a given fan curve to a given fan, loads default configuration if a custom curve is not found
esp_err_t load_fan_curve(uint8_t fan_number, void *curve, size_t length) {
    size_t address = fan_number * length;

    
    esp_err_t result = eeprom_read_block(address, curve, length);
    // Check if a fan curve has been written to the EEPROM, if not load the default fan curve
    if (result != ESP_OK) {
        const uint8_t default_curve[FAN_CURVE_LENGTH] = DEFAULT_FAN_CURVE;
        memcpy(curve, default_curve, length);
        return ESP_ERR_NOT_FOUND;
    }

    return ESP_OK;
}

// save_fan_curve
//
// Saves a given fan curve for a given fan to EEPROM memory
esp_err_t save_fan_curve(uint8_t fan_number, const void *curve, size_t length) {
    size_t address = fan_number * length;

    printf("Setting fan curve for Fan: %d at address: %zu\n", fan_number, address);
    esp_err_t err = eeprom_write_block(address, curve, length);

    if (err == ESP_OK) {
        printf("Fan curve written successfully for Fan: %d\n", fan_number);
    } else {
        printf("Failed to write fan curve for Fan: %d. Error: %s\n", fan_number, esp_err_to_name(err));
    }

    return err;
}


// save_fan_speed_percentage
//
// Saves a fan speed percentage for a given fan to EEPROM memory
esp_err_t save_fan_power_percentage(uint8_t fan_number, uint8_t speed_percentage) {
    size_t address = FAN_SPEED_MEMORY_OFFSET + fan_number;

    printf("Setting fan speed for Fan: %d to %d%% at address: %zu\n", fan_number, speed_percentage, address);
    esp_err_t err = eeprom_write_byte(address, speed_percentage);

    if (err == ESP_OK) {
        printf("Fan speed written successfully for Fan: %d\n", fan_number);
    } else {
        printf("Failed to write fan speed for Fan: %d. Error: %s\n", fan_number, esp_err_to_name(err));
    }

    fan_mode_change[fan_number] = true;
    return err;
}

// load_fan_speed_percentage
//
// Loads a fan speed percentage for a given fan, loads the default value if no saved fan speed is found
esp_err_t load_fan_power_percentage(uint8_t fan_number, uint8_t* fan_power_percentage) {
    size_t address = FAN_SPEED_MEMORY_OFFSET + fan_number;

    esp_err_t result = eeprom_read_byte(address, fan_power_percentage);  // Direct dereference

    if (result != ESP_OK) {
        const uint8_t default_fan_power = DEFAULT_FAN_POWER_PERCENTAGE;
        *fan_power_percentage = default_fan_power;
        printf("No saved fan speed found for Fan %d, loading default value: %d%%\n", fan_number, default_fan_power);
        return ESP_ERR_NOT_FOUND;
    }

    return ESP_OK;
}

// command_handle
//
// Parses and executes commands from Serial communication
void command_handle(const char *command)
{   

    uint8_t fan_number;
    uint8_t fan_curve[FAN_CURVE_LENGTH];
    uint8_t fan_speed_percentage;


    if (strncmp(command, "SET_CURVE", 9) == 0)
    {
        if (sscanf(command, "SET_CURVE %hhu %hhu %hhu %hhu %hhu %hhu %hhu %hhu %hhu %hhu %hhu",
        &fan_number, &fan_curve[0], &fan_curve[1], &fan_curve[2], &fan_curve[3], &fan_curve[4],
        &fan_curve[5], &fan_curve[6], &fan_curve[7], &fan_curve[8], &fan_curve[9]) == FAN_CURVE_LENGTH + 1)
        {
            // SET THE FAN CURVE
            save_fan_curve(fan_number, fan_curve, FAN_CURVE_LENGTH);
            fan_mode_change[fan_number] = true;  // Set the change flag
            fan_curve_change[fan_number] = true; // Set the change flag
        }
        else
        {
            printf("Invalid format for SET_CURVE command. \n");
        }
    }

    else if (strncmp(command, "SET_FAN_SPEED", 13) == 0)
    {
        if (sscanf(command, "SET_FAN_SPEED %hhu %hhu", &fan_number, &fan_speed_percentage) == 2)
        {
            save_fan_power_percentage(fan_number, fan_speed_percentage);
            fan_mode_change[fan_number] = true;  // Set the change flag
        }
        else
        {
            printf("Invalid format for SET_FAN_SPEED command. \n");
        }
    }
    else if (strncmp(command, "SET_FAN_MODE", 12) == 0)
    {
        uint8_t fan_mode;
        if (sscanf(command, "SET_FAN_MODE %hhu %hhu", &fan_number, &fan_mode) == 2) 
        {
            if (fan_mode == 0 || fan_mode == 1)
            {
                fan_mode_record[fan_number] = fan_mode;
                fan_mode_change[fan_number] = true;  // Set the change flag
                fan_mode_change_display[fan_number] = true; // Set the change flag
                
                printf("Fan %d set to %s mode\n", fan_number, fan_mode == 1 ? "Speed" : "Curve");
            }
            else
            {
                printf("Invalid format for SET_FAN_MODE command.\n");
            }
        }
    }
    else{
        printf("Unknown command: %s\n", command);
    }
    
    // TODO
    //
    // GET_FAN_SPEED
    // GET_FAN_CURVE ?
}


#define FAN_NUMBER_TO_MONITOR 0  // Monitor fan 0 by default
#define MONITOR_INTERVAL_MS 5000  // 5000 ms = 5 seconds

// monitor_fan_state 
//
// Monitors the recorded speed and mode settings in EEPROM for a given fan
void monitor_fan_state(uint8_t fan_number) {
    uint8_t fan_curve[FAN_CURVE_LENGTH];
    uint8_t fan_speed_percentage;

    // Load the fan curve from EEPROM
    esp_err_t result = load_fan_curve(fan_number, fan_curve, FAN_CURVE_LENGTH);
    if (result == ESP_OK) {
        printf("Loaded fan curve for Fan %d: ", fan_number);
        for (int i = 0; i < FAN_CURVE_LENGTH; i++) {
            printf("%d ", fan_curve[i]);
        }
        printf("\n");
    } else {
        printf("Failed to load fan curve for Fan %d. Error: %s\n", fan_number, esp_err_to_name(result));
    }

    // Load the fan speed from EEPROM
    result = eeprom_read_byte(FAN_SPEED_MEMORY_OFFSET + fan_number, &fan_speed_percentage);
    if (result == ESP_OK) {
        printf("Loaded fan speed for Fan %d: %d%%\n", fan_number, fan_speed_percentage);
    } else {
        printf("Failed to load fan speed for Fan %d. Error: %s\n", fan_number, esp_err_to_name(result));
    }
}

////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
// FAN CONTROL FUNCTIONS


// fan_pwm_init
//
// Initializes the PWM settings for fan power control
void fan_pwm_init(uint8_t fan_channel, uint8_t gpio_pin)
{

    // Configure the LEDC peripheral used for PWM 
    ledc_timer_config_t ledc_t_config = {
        .speed_mode = LEDC_MODE,
        .timer_num = LEDC_TIMER,
        .freq_hz = LEDC_FREQ,
        .duty_resolution = LEDC_RESOLUTION , 
        .clk_cfg = LEDC_AUTO_CLK    
    };

    ledc_timer_config(&ledc_t_config); // Load the timer configuration


    // Configure the LEDC channel for the fan

    ledc_channel_config_t ledc_ch_config = {
        .speed_mode = LEDC_MODE,
        .channel = fan_channel,
        .timer_sel = LEDC_TIMER,
        .intr_type = LEDC_INTR_DISABLE,
        .gpio_num = gpio_pin,
        .duty = 0, // Initialize the duty cycle to 0% 
        .hpoint = 0,
    };

    ledc_channel_config(&ledc_ch_config); // Load the channel configuration
}

// adjust_fan_percentage
//
// Adjusts the duty cycle of the PWM signal controlling a given fan
void adjust_fan_percentage(uint8_t fan_channel, uint8_t duty_percentage)
{
    uint8_t duty_cycle = 255 * duty_percentage / 100;
    ledc_set_duty(LEDC_MODE, fan_channel, duty_cycle);
    ledc_update_duty(LEDC_MODE, fan_channel);

    printf("Adjusted fan power percentage to %d\n", duty_percentage);
}

// temperature_to_fan_curve
//
// Maps temperatures to duty cycle percentages in the fan curve
uint8_t temperature_to_fan_curve(float temperature, uint8_t fan_curve[]) 
{
    if (temperature <= 25) return fan_curve[0];
    else if (temperature <= 30) return fan_curve[1];
    else if (temperature <= 32) return fan_curve[2];
    else if (temperature <= 34) return fan_curve[3];
    else if (temperature <= 36) return fan_curve[4];
    else if (temperature <= 38) return fan_curve[5];
    else if (temperature <= 40) return fan_curve[6];
    else if (temperature <= 42) return fan_curve[7];
    else if (temperature <= 44) return fan_curve[8];
    else return fan_curve[9];  // Max speed for higher temperatures
}


// Store the last known temperature interval for each fan to avoid unnecessary updates
static uint8_t last_fan_interval[4] = {255, 255, 255, 255};  // Initialize to an invalid value (255)

// get_temperature_interval
//
// Finds to which interval a temperature falls to 
uint8_t get_temperature_interval(float temperature) {
    // Return the interval based on temperature ranges
    if (temperature <= 30) return 0;
    else if (temperature <= 32) return 1;
    else if (temperature <= 34) return 2;
    else if (temperature <= 36) return 3;
    else if (temperature <= 38) return 4;
    else if (temperature <= 40) return 5;
    else if (temperature <= 42) return 6;
    else if (temperature <= 44) return 7;
    else if (temperature <= 46) return 8;
    else return 9;  // Max interval for temperatures above 90°C
}


bool loaded [4] = {false, false, false, false};
bool curve_change[4] = {false, false, false, false};
uint8_t fan_curve[FAN_CURVE_LENGTH];
esp_err_t result;
//
// fan_control
//
// Controls fan speeds depending on the mode of operation, settings writen to EEPROM memory and temperatures
void fan_control(uint8_t fan_number, uint8_t fan_channel, float* temperatures) {


    



    if (fan_mode_record[fan_number]) {  // Fan is in speed mode
        if (fan_mode_change[fan_number]) {
            // Load the saved fan speed percentage from EEPROM
            uint8_t fan_power_percentage;
            load_fan_power_percentage(fan_number, &fan_power_percentage);
            adjust_fan_percentage(fan_channel, fan_power_percentage);
            printf("Fan %d in Speed Mode, Fan Duty: %d%%\n", fan_number + 1, fan_power_percentage);

            // Reset the change flag once the speed is set
            fan_mode_change[fan_number] = false;
        }
        // In speed mode, we do nothing further after setting the speed once.
    } 
    else {  // Fan is in curve mode (dynamic mode)

        
        
        if (!loaded[fan_number])
        {
            printf("Not loaded\n");
        }

        if (fan_curve_change[fan_number])
        {
            printf("Fan curve changed\n");
        }
        if (!loaded[fan_number])
        {
            // Load the fan curve for dynamic adjustment based on temperature
            
            esp_err_t result = load_fan_curve(fan_number, fan_curve, FAN_CURVE_LENGTH);
            loaded[fan_number] = true;
        }
        if (fan_curve_change[fan_number])
        {
            esp_err_t result = load_fan_curve(0, fan_curve, FAN_CURVE_LENGTH);
            curve_change[fan_number] = true;
        }
        // Check if loading the fan curve was successful
        if (result == ESP_OK) {
            //printf("Fan curve for Fan BLA BLA %d loaded successfully from EEPROM:\n ", fan_number);
        } else {
            //printf("Failed to load fan curve for Fan %d from EEPROM. Loading default fan curve.\n", fan_number);
        }


        // Read the current temperature from the temperature array (external sensor)
        float temperature = temperatures[fan_number];  // Assume temperatures array is updated elsewhere

        // Determine the current temperature interval
        uint8_t current_interval = get_temperature_interval(temperature);
        //printf("Current Interval: %d \n", current_interval);

        // Only update the fan speed if the temperature has moved to a different interval
        if (current_interval != last_fan_interval[fan_number] || curve_change[fan_number]) {
            uint8_t duty_percentage = fan_curve[current_interval];  // Map to the new interval
            adjust_fan_percentage(fan_channel, duty_percentage);
            printf("Fan %d in Curve Mode, Temperature: %.2f°C, Fan Duty: %d%%\n", fan_number, temperature, duty_percentage);
            // Update the last known interval
            last_fan_interval[fan_number] = current_interval;
        }

        if (curve_change[fan_number])
        {
            fan_curve_change[fan_number] = false;
            curve_change[fan_number] = false;
        }
    }
}


// fan_control_master
//
// Controls all fan speeds 

void fan_control_master(float* temperatures)
{
    fan_control(FAN1_NUM, LEDC_CHANNEL_0, temperatures);
    fan_control(FAN2_NUM, LEDC_CHANNEL_1, temperatures);
    fan_control(FAN3_NUM, LEDC_CHANNEL_2, temperatures);
    fan_control(FAN4_NUM, LEDC_CHANNEL_3, temperatures);

}


/////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

// OLED Display Function

// set_display_start_line
//
// Changes the start line of the display, start line between 0 and 63
void set_display_start_line(uint_fast8_t start_line) {

    if (start_line <= 63) {
        i2c_write_byte(OLED_CMD_SET_DISPLAY_START_LINE | start_line, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
    }
}

// reset_display_addressing
//
// Resets the addresing of columns and pages
void reset_display_addressing(uint8_t page)
{
    i2c_write_byte(0x00, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED); // Reset column address low bits
	i2c_write_byte(0x10, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED); // Reset column address high bits
	i2c_write_byte(0xB0 | page, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED); // Reset page address
}

// display_init
//
// Sends the startup sequence through I2C to initialize the display
void display_init() {

	i2c_start_condition(SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
	i2c_write_byte((OLED_I2C_ADDRESS << 1) | WRITE_BIT,SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
	i2c_write_byte(OLED_CONTROL_BYTE_CMD_STREAM, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);

	i2c_write_byte(OLED_CMD_SET_CHARGE_PUMP_CTRL, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED); // Tell the display to configure the charge pump
	i2c_write_byte(OLED_CMD_SET_CHARGE_PUMP_ON, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED); // Turn the charge pump on 


    i2c_write_byte(OLED_CMD_SET_SEGMENT_REMAP_INVERSE, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED); // reverse left-right mapping
	i2c_write_byte(OLED_CMD_SET_COM_SCAN_MODE_REVERSE, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED); // reverse up-bottom mapping

	i2c_write_byte(OLED_CMD_DISPLAY_ON, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED); // Turn the display on

	reset_display_addressing(0);
    i2c_write_byte(0x40, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED); // Set start line
    i2c_write_byte(OLED_CMD_SET_DISPLAY_OFFSET, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED); // Align starting position
    i2c_write_byte(0x00, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED); // Offset to 0

	i2c_stop_condition(SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);

}

// display_clear
//
// Clears the display and turns all pixels to black
void display_clear() {
	

	uint8_t zero[132];
    memset(zero, 0, 132);
	for (uint8_t i = 0; i < 8; i++) {
		
		i2c_start_condition(SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
		i2c_write_byte((OLED_I2C_ADDRESS << 1) | WRITE_BIT, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
		i2c_write_byte(OLED_CONTROL_BYTE_CMD_SINGLE, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
		i2c_write_byte(0xB0 | i, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED); // Set the page address

		i2c_write_byte(OLED_CONTROL_BYTE_DATA_STREAM, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
		for (int j = 0; j < 132; j++) {
            i2c_write_byte(zero[j], SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);  // Write zero to each column
        }
		i2c_stop_condition(SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
		
	}

    
    i2c_start_condition(SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
    i2c_write_byte(OLED_CONTROL_BYTE_CMD_STREAM, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
    reset_display_addressing(0);
    i2c_stop_condition(SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
    
}

// display_text
//
// Displays a given text on the OLED screen, supports multiline 
void display_text(const void *input_text) {
    char *text = (char*)input_text;
    uint8_t text_len = strlen(text);
    uint8_t page = 0;

    // Initialize column offset for the first line
    i2c_start_condition(SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
    i2c_write_byte((OLED_I2C_ADDRESS << 1) | WRITE_BIT, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);

    i2c_write_byte(OLED_CONTROL_BYTE_CMD_STREAM, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
    // Shift the first line by 8 columns for alignment
    i2c_write_byte(0x04, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);  
    i2c_write_byte(0x10, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
    i2c_write_byte(0xB0, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);

    i2c_stop_condition(SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);

    for (uint8_t i = 0; i < text_len; i++) {
        if (text[i] == '\n') {
            i2c_start_condition(SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
            i2c_write_byte((OLED_I2C_ADDRESS << 1) | WRITE_BIT, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
            i2c_write_byte(OLED_CONTROL_BYTE_CMD_STREAM, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
            i2c_write_byte(0x04, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED); // Shift by 8 columns for alignment
            i2c_write_byte(0x10, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
            page++;
            i2c_write_byte(0xB0 | page, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED); // Move to the next page
            i2c_stop_condition(SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
        } 
        else {
            i2c_start_condition(SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
            i2c_write_byte((OLED_I2C_ADDRESS << 1) | WRITE_BIT, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
            i2c_write_byte(OLED_CONTROL_BYTE_DATA_STREAM, SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
            for (int j = 0; j < 8; j++) {
                i2c_write_byte(font8x8_basic_tr[(uint8_t)text[i]][j], SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
            }
            i2c_stop_condition(SDA_PIN_OLED, SCL_PIN_OLED, I2C_DELAY_OLED);
        }
    }
}

// display_all_fan_info
//
// Displays the temperature and power level information for all 4 fans
void display_all_fan_info(uint8_t fan1_temp, uint8_t fan2_temp, uint8_t fan3_temp, uint8_t fan4_temp)
{
    char display_buffer[128];

    uint8_t fan1_level; 
    uint8_t fan2_level;
    uint8_t fan3_level;
    uint8_t fan4_level;

    uint8_t fan1_interval;
    uint8_t fan2_interval;
    uint8_t fan3_interval;
    uint8_t fan4_interval;

    uint8_t fan1_curve[FAN_CURVE_LENGTH];
    uint8_t fan2_curve[FAN_CURVE_LENGTH];
    uint8_t fan3_curve[FAN_CURVE_LENGTH];
    uint8_t fan4_curve[FAN_CURVE_LENGTH];



    if (fan_curve_change[FAN1_NUM] || fan_mode_change[FAN1_NUM])
    {
        load_fan_curve(FAN1_NUM, fan1_curve, FAN_CURVE_LENGTH);
    }
    if (fan_curve_change[FAN2_NUM] || fan_mode_change[FAN2_NUM])
    {
        load_fan_curve(FAN2_NUM, fan2_curve, FAN_CURVE_LENGTH);
    }
    if (fan_curve_change[FAN3_NUM] || fan_mode_change[FAN3_NUM])
    {
        load_fan_curve(FAN3_NUM, fan3_curve, FAN_CURVE_LENGTH);
    }
    if (fan_curve_change[FAN4_NUM] || fan_mode_change[FAN4_NUM])
    {
        load_fan_curve(FAN4_NUM, fan4_curve, FAN_CURVE_LENGTH);
    }

    // Load fan levels from memory
    if (fan_mode_record[0]){
    load_fan_power_percentage(FAN1_NUM, &fan1_level);
    printf("I am here\n");
    }
    else{
        fan1_interval = get_temperature_interval(fan1_temp);
        fan1_level = fan1_curve[fan1_interval];
        printf("FAN1 Level: %d\n", fan1_level);
    }   

    if (fan_mode_record[1]){
    load_fan_power_percentage(FAN2_NUM, &fan2_level);
    }
    else{
        fan2_interval = get_temperature_interval(fan2_temp);
        fan2_level = fan2_curve[fan2_interval];
        
    }

    if (fan_mode_record[2]){
    load_fan_power_percentage(FAN3_NUM, &fan3_level);
    }
    else{
        fan3_interval = get_temperature_interval(fan3_temp);
        fan3_level = fan3_curve[fan3_interval];
        
    }

    if (fan_mode_record[3]){
    load_fan_power_percentage(FAN4_NUM, &fan4_level);
    }
    else{
        fan4_interval = get_temperature_interval(fan4_temp);
        fan4_level = fan4_curve[fan4_interval];
        
    }
    
    // Format the fan info display text
    sprintf(display_buffer, "FAN 1: %dC %d%%\n\nFAN 2: %dC %d%%\n\nFAN 3: %dC %d%%\n\nFAN 4: %dC %d%%\n\n",
     fan1_temp, fan1_level, fan2_temp, fan2_level, fan3_temp, fan3_level, fan4_temp, fan4_level);

    // Display the general fan info
     display_text(display_buffer);
}

// display_individual_fan_info
//
// Displays temperature, fan power level and fan curve info for the selected fan
void display_individual_fan_info(uint8_t fan_number, uint8_t fan_temp)
{
    char display_buffer[256];


    if (fan_mode_change_display[fan_number])
    {
        display_clear();
        fan_mode_change_display[fan_number] = false; // Reset the flag
    }


    if (fan_mode_record[fan_number]) // SPEED MODE
    {
        uint8_t fan_level;

        load_fan_power_percentage(fan_number, &fan_level);

        sprintf(display_buffer, "\n\n\nFAN %d: %dC %d%%", fan_number + 1, fan_temp, fan_level);

        display_text(display_buffer);
    }
    else // CURVE MODE
    {   
        uint8_t fan_curve[FAN_CURVE_LENGTH];
        load_fan_curve(fan_number, &fan_curve, FAN_CURVE_LENGTH);

        sprintf(display_buffer, "FAN 1 Curve:\n\n0) %-5d5) %d\n1) %-5d6) %d\n2) %-5d7) %d\n3) %-5d8) %d\n4) %-5d9) %d",
        fan_curve[0], fan_curve[5], fan_curve[1], fan_curve[6], fan_curve[2], fan_curve[7], fan_curve[3], fan_curve[8], fan_curve[4], fan_curve[9]);


        display_text(display_buffer);
    }
}






///////////////////////////////////////////////////////////////////////////

// MENU DISPLAY AND STATE MACHINES



int button_read(gpio_num_t button_pin)
{   
    int state = gpio_get_level(button_pin);
    return !state;
    /*
    printf("Button state: %d\n", state);  // Print the state variable here
    vTaskDelay(pdMS_TO_TICKS(10));
    if (state == gpio_get_level(button_pin))
    {   
        return state;
    }
    else{
        return -1;
    }*/
}

void display_info(uint8_t fan1_temp, uint8_t fan2_temp, uint8_t fan3_temp, uint8_t fan4_temp)
{
    if (!button_read(14))
    {
        display_mode = !display_mode;
        display_clear();
        printf("INFO CHANGE\n");
    }

    if (display_mode)
    {
        display_all_fan_info(fan1_temp, fan2_temp, fan3_temp, fan4_temp);
    }
    else
    {
        display_individual_fan_info(FAN_NUMBER_TO_MONITOR, fan1_temp);
    }
}

typedef enum {
    MAIN_MENU,
    FAN_INFO,
    FAN_CONFIGURATION,
    FAN_SETTINGS,
    CHANGE_CURVE,
    ADJUST_VALUE
} MenuState;


MenuState current_state = MAIN_MENU;

int selected_option = 0;
int fan_setting_number = 0;
bool adjust_value_mode = 1;






#define POTENTIOMETER_ADC_CHANNEL ADC_CHANNEL_0  // ADC channel (GPIO 36)
#define ADC_ATTEN ADC_ATTEN_DB_12  // Set the ADC attenuation for 0-3.3V range

adc_cali_handle_t cali_handle;  // ADC calibration handle
adc_oneshot_unit_handle_t adc1_handle;  // ADC handle for oneshot mode

// Function to initialize the ADC calibration using line fitting
void init_adc_calibration() {
    adc_cali_line_fitting_config_t cali_config = {
        .atten = ADC_ATTEN,  // Set attenuation for 0-3.3V range
        .bitwidth = ADC_BITWIDTH_12  // Set the ADC resolution to 12 bits
    };

    // Initialize line fitting calibration scheme
    esp_err_t ret = adc_cali_create_scheme_line_fitting(&cali_config, &cali_handle);
    if (ret == ESP_OK) {
        printf("ADC calibration initialized successfully.\n");
    } else {
        printf("Failed to initialize ADC calibration: %s\n", esp_err_to_name(ret));
    }
}

// Function to initialize the ADC oneshot driver
void init_adc_oneshot() {
    adc_oneshot_unit_init_cfg_t unit_cfg = {
        .unit_id = ADC_UNIT_1
    };

    // Initialize ADC1 in oneshot mode
    ESP_ERROR_CHECK(adc_oneshot_new_unit(&unit_cfg, &adc1_handle));

    adc_oneshot_chan_cfg_t config = {
        .atten = ADC_ATTEN,      // Set the attenuation
        .bitwidth = ADC_BITWIDTH_12  // Set the resolution to 12 bits
    };

    // Configure the ADC channel
    ESP_ERROR_CHECK(adc_oneshot_config_channel(adc1_handle, POTENTIOMETER_ADC_CHANNEL, &config));
}

// Function to read potentiometer value using ADC oneshot mode and calibration
uint8_t read_potentiometer_value() {
    int adc_raw = 0;

    // Read the raw ADC value in oneshot mode
    ESP_ERROR_CHECK(adc_oneshot_read(adc1_handle, POTENTIOMETER_ADC_CHANNEL, &adc_raw));

    // Convert raw ADC value to calibrated voltage using the calibration handle
    int voltage = 0;
    esp_err_t ret = adc_cali_raw_to_voltage(cali_handle, adc_raw, &voltage);
    
    
    if (ret == ESP_OK) {
        // Map the calibrated voltage to a percentage (0 - 100%)
        uint8_t percentage_value = (((voltage - 300) * 100) / 3102) ;
        return percentage_value;
    } else {
        printf("Failed to read calibrated ADC value: %s\n", esp_err_to_name(ret));
        return 0;  // Return 0 if there was an error
    }
}


// 1 For Speed Mode
// 0 For Curve Mode
void display_adjust_value(uint8_t value) {
    char display_buffer[64];

    // Simply show the adjusted value in the center of the display
    sprintf(display_buffer, "\n\n  %3d%%", value);  // Display the value as a percentage
    display_text(display_buffer);
}


void handle_adjust_value()
{   

    uint8_t value;
    uint8_t fan_curve[FAN_CURVE_LENGTH];
    // Continuously adjust the value dynamically using the potentiometer
    value = read_potentiometer_value();

    if (value)
    display_adjust_value(value);


    if (button_read(CONFIRM_BUTTON))
    {
        if (adjust_value_mode == MODE_CURVE) // Curve Mode
        {
            load_fan_curve(fan_setting_number, &fan_curve, FAN_CURVE_LENGTH);
            fan_curve[selected_option] = value;
            save_fan_curve(fan_setting_number, fan_curve, FAN_CURVE_LENGTH);
            fan_curve_change[fan_setting_number] = true;
            printf("\n\nFAN SETTING NUMBER: %d\n\n", fan_setting_number);
        }
        else if (adjust_value_mode == MODE_POWER) // Speed Mode
        {
            save_fan_power_percentage(fan_setting_number, value);
            fan_mode_change[fan_setting_number] = true;
        }


        current_state = (adjust_value_mode == MODE_CURVE ) ? CHANGE_CURVE : FAN_SETTINGS;
        display_clear();

    }
    if (button_read(BACK_BUTTON))
    {
        current_state = (adjust_value_mode == MODE_CURVE ) ? CHANGE_CURVE : FAN_SETTINGS;
        display_clear();
    }
    
}




// FAN 1 Curve:
//
// 0)  25   5) 60
// 1)  30   6) 70
// 2)> 40   7) 80
// 3)  50   8) 90
// 4)  60   9)100

void display_change_curve() {
    char display_buffer[256];  // Buffer to hold the display content
    uint8_t fan_curve[FAN_CURVE_LENGTH];

    // Load the fan curve for the selected fan
    load_fan_curve(fan_setting_number, fan_curve, FAN_CURVE_LENGTH);

    // Display fan curve with the cursor appearing between the index and the value
    sprintf(display_buffer, "FAN %d Curve:\n\n", fan_setting_number + 1);

    // Add first half of the curve (0-4) and second half (5-9), with cursor between index and value
    sprintf(display_buffer + strlen(display_buffer), 
        "0)%s%d   5)%s%d\n1)%s%d   6)%s%d\n2)%s%d   7)%s%d\n3)%s%d   8)%s%d\n4)%s%d   9)%s%d",
        (selected_option == 0) ? ">" : " ", fan_curve[0], (selected_option == 5) ? ">" : " ", fan_curve[5],
        (selected_option == 1) ? ">" : " ", fan_curve[1], (selected_option == 6) ? ">" : " ", fan_curve[6],
        (selected_option == 2) ? ">" : " ", fan_curve[2], (selected_option == 7) ? ">" : " ", fan_curve[7],
        (selected_option == 3) ? ">" : " ", fan_curve[3], (selected_option == 8) ? ">" : " ", fan_curve[8],
        (selected_option == 4) ? ">" : " ", fan_curve[4], (selected_option == 9) ? ">" : " ", fan_curve[9]);

    // Display the content
    display_text(display_buffer);
}


// Updates the curve page when a new curve point is hovered
// Selected option remains the same
void handle_change_curve() {
    // Handle navigation between curve points using the navigation button
    if (button_read(NAVIGATE_BUTTON)) {
        selected_option = (selected_option + 1) % FAN_CURVE_LENGTH;  // Move to the next curve point, wrap around
        display_change_curve();  // Update the display with the new selection
    }

    // Handle confirming the selection of a curve point for adjustment
    if (button_read(CONFIRM_BUTTON)) {
        current_state = ADJUST_VALUE;
        display_clear();
        adjust_value_mode = 0; // The adjustment is going to adjust a curve point
    }

    if (button_read(BACK_BUTTON)) {
        current_state = FAN_SETTINGS;
        display_clear();
        selected_option = 0; // Reset the hovered fan
    }
}













//   Fan Number
// > 1. Current Mode : Mode
//   2. Change Curve
//   3. Change Power
//

void display_fan_settings() {
    char buffer[128];  // Use a single buffer for all display text

    // Determine the current mode of the selected fan (Speed or Curve)
    const char* mode_text = fan_mode_record[fan_setting_number] ? "Speed" : "Curve";

    // Generate the display content based on the selected option
    if (selected_option == 0) {
        sprintf(buffer, " Fan %d Settings\n\n>1.Mode: %s\n 2.Change Curve\n 3.Change Power", fan_setting_number + 1, mode_text);
    } else if (selected_option == 1) {
        sprintf(buffer, " Fan %d Settings\n\n 1.Mode: %s\n>2.Change Curve\n 3.Change Power", fan_setting_number + 1, mode_text);
    } else {
        sprintf(buffer, " Fan %d Settings\n\n 1.Mode: %s\n 2.Change Curve\n>3.Change Power", fan_setting_number + 1, mode_text);
    }

    // Display the content
    display_text(buffer);
}


// Updates the setting screen with the new option hovered 
// Updates the setting screen when fan mode is toggled
void handle_fan_settings() {
    if (button_read(NAVIGATE_BUTTON)) {
        // Move between the settings options (mode, curve, power)
        selected_option = (selected_option + 1) % 3;
        display_fan_settings();  // Update the screen with the new option selected
    }

    if (button_read(CONFIRM_BUTTON)) {
        // Confirm the option and transition to the corresponding screen
        if (selected_option == 0) {
            // Toggle fan mode (Speed/Curve)
            fan_mode_record[fan_setting_number] = !fan_mode_record[fan_setting_number];
            fan_mode_change[fan_setting_number] = true;
            display_fan_settings();  // Re-display fan settings with the updated mode
        } else if (selected_option == 1) {
            current_state = CHANGE_CURVE;
            display_clear();  // Clear screen when transitioning to Change Curve page
            selected_option = 0; // Reset the selected optıon in state transition
        } else if (selected_option == 2) {
            current_state = ADJUST_VALUE;
            display_clear();  // Clear screen when transitioning to Change Power page
            selected_option= 0; // Reset the selected option in state transition
        }
    }

    if (button_read(BACK_BUTTON))
    {
        current_state = FAN_CONFIGURATION;
        display_clear();
        selected_option = 0; // Reset the hovered fan
    }
}





// Fan Configuration Functions


// > Fan1
//   Fan2
//   Fan3
//   Fan4

void display_fan_configuration() {
    // Update the screen without clearing, just display fan selection
    switch (selected_option) {
        case 0:
            display_text("Choose FAN\n\n> Fan 1\n  Fan 2\n  Fan 3\n  Fan 4");
            break;
        case 1:
            display_text("Choose FAN\n\n  Fan 1\n> Fan 2\n  Fan 3\n  Fan 4");
            break;
        case 2:
            display_text("Choose FAN\n\n  Fan 1\n  Fan 2\n> Fan 3\n  Fan 4");
            break;
        case 3:
            display_text("Choose FAN\n\n  Fan 1\n  Fan 2\n  Fan 3\n> Fan 4");
            break;
    }
}


// Updates fan config page when new option is hovered
// Changes the state to fan settings
// Resets the hovered fan
void handle_fan_configuration() {
    if (button_read(NAVIGATE_BUTTON))
    {// Move the cursor between fans
        selected_option = (selected_option + 1) % 4;
        display_fan_configuration();  // Update the screen with the new fan selected
    }

    if (button_read(CONFIRM_BUTTON)) {
        // Confirm the selected fan and move to the fan settings page
        current_state = FAN_SETTINGS;
        display_clear();  // Clear screen when transitioning to Fan Settings
        fan_setting_number = selected_option; // Store the confirmed fan number
        selected_option = 0; // Reset the hovered fan
    }

    if (button_read(BACK_BUTTON))
    {
        current_state = MAIN_MENU;
        display_clear();
        selected_option = 0; // Reset the hovered fan
    }
}






// Fan Info Functions

// FAN1: 23C 50%
// FAN2: 27C 100%
// FAN3: 12C 20%
// FAN4: 22C 40%
void display_fan_info(uint8_t fan1_temp,uint8_t fan2_temp,uint8_t fan3_temp,uint8_t fan4_temp)
{
    display_all_fan_info(fan1_temp, fan2_temp, fan3_temp, fan4_temp);
}

// Changes the state to menu
// Clears the display
void handle_fan_info()
{   
    
    if (button_read(BACK_BUTTON))
    {   
        printf("Reading back button!!!!!!!!!!!!!!!!\n");
        // Transition back to the main menu, so clear the display first
        current_state = MAIN_MENU;
        display_clear();
    }
}


// Main Menu Functions 

// 1. Fan Info
// 2. Fan Configuration
void display_main_menu() {
    // Only update the text, don't clear the display
    if (selected_option == 0) {
        display_text("MAIN MENU\n\n>1.Fan Info\n 2.Fan Config");
    } else {
        display_text("MAIN MENU\n\n 1.Fan Info\n>2.Fan Config");
    }
}


// Changes the state
// Clears the display
// Resets selected option
// Updates menu screen when different option is hovered
void handle_main_menu() {
    if (button_read(NAVIGATE_BUTTON)) {
        // Move the cursor (view) between options
        selected_option = (selected_option + 1) % 2;
        display_main_menu();  // Update the menu when the cursor moves
    }

    if (button_read(CONFIRM_BUTTON)) {
        // When confirm is pressed, select the highlighted option
        if (selected_option == 0) {
            current_state = FAN_INFO;
            display_clear();  // Clear the screen when changing to the Fan Info page
            selected_option = 0;  // Reset when transitioning to a new state
        } else {
            current_state = FAN_CONFIGURATION;
            display_clear();  // Clear the screen when changing to Fan Configuration]
            selected_option = 0;  // Reset when transitioning to a new state
        }
    }
}




void handle_state_machine(uint8_t fan1_temp, uint8_t fan2_temp, uint8_t fan3_temp, uint8_t fan4_temp) 
{
    switch (current_state) {
        case MAIN_MENU:
            display_main_menu();
            handle_main_menu();
            break;

        case FAN_INFO:
            display_fan_info(fan1_temp, fan2_temp, fan3_temp, fan4_temp);
            handle_fan_info();
            break;

        case FAN_CONFIGURATION:
            display_fan_configuration();
            handle_fan_configuration();
            break;

        case FAN_SETTINGS:
            display_fan_settings();
            handle_fan_settings();
            break;

        case CHANGE_CURVE:
            display_change_curve();
            handle_change_curve();
            break;

        case ADJUST_VALUE:
            handle_adjust_value();
            break;
        }
}




// Main Loop
void app_main()
{   

    // Initialize ADC calibration
    init_adc_calibration();

    // Initialize ADC oneshot mode
    init_adc_oneshot();

    // Initializa fan mode and change recordings 
    for (uint8_t i = 0; i < 4; i++) {
        fan_mode_record[i] = true; // Set all fans to speed mode for testing
        fan_mode_change[i] = false; // Initialize change flags to false
        fan_curve_change[i] = false;
    }

    // Erase NVS to simulate clearing the EEPROM
    esp_err_t success = nvs_flash_erase();
    if (success != ESP_OK) {
        printf("Failed to erase NVS: %s\n", esp_err_to_name(success));
    }

    // Initialize NVS (Non-Volatile Storage)
    esp_err_t ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);

    // Initialize UART
    uart_config_t uart_config = {
        .baud_rate = 9600,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
    };
    uart_param_config(UART_NUM_0, &uart_config);
    uart_driver_install(UART_NUM_0, 1024, 0, 0, NULL, 0);
    uint8_t data[UART_BUFFER_SIZE]; // Initialize the buffer to hold the commands coming from UART

    
    // Initialize a default fan curve
    uint8_t fan_curve[FAN_CURVE_LENGTH] = DEFAULT_FAN_CURVE;
    save_fan_curve(FAN_NUMBER_TO_MONITOR, fan_curve, FAN_CURVE_LENGTH);
    
    // Initialize a default fan speed
    uint8_t fan_speed_percentage = 50;
    
    save_fan_power_percentage(FAN1_NUM, fan_speed_percentage);
    save_fan_power_percentage(FAN2_NUM, fan_speed_percentage);
    save_fan_power_percentage(FAN3_NUM, fan_speed_percentage);
    save_fan_power_percentage(FAN4_NUM, fan_speed_percentage);

    printf("Default fan curve and speed saved to EEPROM.\n");

    // Initialize PWM for Fans
   
    fan_pwm_init(LEDC_CHANNEL_0, FAN1_PIN); // GPIO 32
    fan_pwm_init(LEDC_CHANNEL_1, FAN2_PIN); // GPIO 33
    fan_pwm_init(LEDC_CHANNEL_2, FAN3_PIN);
    fan_pwm_init(LEDC_CHANNEL_3, FAN4_PIN);

    // Start the fan with the default fan speed
    //uint8_t fan_power_percentage;
    //load_fan_power_percentage(FAN1_NUM, &fan_power_percentage);
    //adjust_fan_percentage(FAN1_CHANNEL, fan_power_percentage);
    //printf("Default fan speed applied for Fan 1.\n");  

    // Start ADC I2C communcation and configure SDA and SCL gpio pins
    printf("Starting ADC I2C communication\n");
    i2c_configure_gpio(21, 22, true);

    // Start OLED Display I2C communication and configure the SDA and SCL gpio pins
    printf("Starting OLED Display I2C communication\n");
    i2c_configure_gpio(26, 27, false);

    // Initialize the OLED display
    display_init();
    vTaskDelay(pdMS_TO_TICKS(100));
    display_clear();
    float fan_temps[4];
    // Main loop to listen for UART commands and monitor fan state
    while (1) {
        // Read data from UART
        int length = uart_read_bytes(UART_NUM_0, data, UART_BUFFER_SIZE - 1, 20 / portTICK_PERIOD_MS);
        if (length > 0) {
            data[length] = '\0';  // Null-terminate the received string
            printf("Received: %s\n", data);
            command_handle((char *)data);  // Parse and execute the received command
        }

        // Read temperatures from the sensors
        ads1115_read_all(ADS1115_ADDR1, fan_temps);

      


        fan_control_master(fan_temps);

        handle_state_machine(fan_temps[0], fan_temps[1], fan_temps[2], fan_temps[3]);

        vTaskDelay(pdMS_TO_TICKS(50));  // Delay for the monitoring interval
}


